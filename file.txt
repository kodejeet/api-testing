for the first get request we need the api url

url =  https://simple-books-api.click/ 

this one will get the message = {"message":"Welcome to the Simple Books API."}

now there is another endpoint, the /status/ endpoint, returns when provided with the GET request
 msg = {
    "message": "Welcome to the Simple Books API."
}

now, we can also configure the params that we want to GET 


we can also create. collections and there we can have the API url https://simple-books-api.click/ as the 
variables set as baseURL lets suppose , we have to select the scope like env , global , or collections

now there is the intitial value (public, can be shared)and the current value (private) 


// Query Parameters now :

 go to the params to search thru the response we have got , now enter the key value pair accordingly and we can filter 
 out the results : {"id":2,"name":"Just as I Am","type":"non-fiction","available":false}
 
where key = type and value = non-fiction  

more like a database Query and results


// ASSIGNMENT :

{{baseURL}}/books/?limit=4 , returns with only 6 of those books (has to be 1-20)


//path variables 

it was -- :bookId, it has a more detailed response

path variables are not similar query Parameters

 
now we want to order books using the book id , but first we have to add our authorization to our variables

created two POST request in the collection. now we have one api-clients and Order Book, 

to use order book we first have to register ourselves as a client. 

go to the api cliets , add {
   "clientName": "kode",
   "clientEmail": "kode@gmail.com"
}

this shall be done in body => raw => JSON > enter

we get a response , accessToken : a very long string

use this same accessToken to create ourselves a vairable so that i can be reused overall project

{{accessToken}} as the CURRENT VALUE which is totally private unless shared 

now go to the request tab and select authorization => Bearer Token add the {{accessToken}} 

now we are authorized , we go to the Order Books and then we put this format but the name could be anything : 


the order is placed with a response message : created : true , orderId : some string literal 


for you to get the list of books just do a GET request on {{baseURL}}/orders/ and then add the 
accessToken in the authoriazation bearer token , then boom

ordering a book but with random name this time : 

just put "customerName": "{{$randomFullName}}" along with the bookId

now to check what we have sent over the request , goto terminal , clear logs send again 

get order details per id : orders/:orderId

// PATCH REQUEST

more like update the already existing data on the server/db


to update it : put the orderId in the path variables and patch request at {{baseURL}}/orders/:orderId

send, the response status code will be 204 , and the body will be null (phi)

now check again on the list of books ordered and we can see the change in it 



// DELETE AND ORDER 

same as the patch method



*this was the wrap, now we learn how to write scripts in postman for bigger systems*

when we send the {{baseURL}}/status we get a status OK , but we can tell the Postman to test this for use

for that we have to wrtie  scripts :


from the snippets we get : 

pm.test("Status code is 200", function () {
    pm.response.to.have.status(200);
});

// to get the response messages in the console directly, different ways : 

console.log(response)

console.log(response.json)

console.log(response['status'])


now we have our own function to fire a get request

code : 

pm.test("Status should be OK", () => {
    // no error
    // pm.expect(1).to.eql(1);
    // error
    // pm.expect(1).to.eql(2);

    pm.expect(response.status).to.eql('OK');
});

we can always test all the endpoint with diff methods using scripts/tests :

the most common test code is : 

pm.test("Status code is 200", () => {
    pm.response.to.have.status(200);
});


just the status codes needs to be changed, 200 for get , 201 for put and 204 for patch/DELETE

we can also run the scripts for all the endpoints in the collection at once too.


// WRITING SCRIPTS IN DEPTH

lets suppose there are 10 books in the library and 6 of them are available and the rest aren't there
so how do we extract from the response in postman into getting me the first book that's available
the response comes in javascript arrays of objects , [{0}, {1}, {2}]


in order to get me the first book available , the first element needs to be accessed through the postman scripts


const response = pm.response.json();

const firstAvaiblableBooks = response.filter((book) => 
    book.available === true
)

console.log(firstAvaiblableBooks[0]) // [0]

// this line creates the bookId as a variable and the current value for it to be 1, which was available
pm.globals.set("bookId", firstAvaiblableBooks[0].id);

// FINAL OVERVIEW : 


pm.test("Status code is 200", () => {
    pm.response.to.have.status(200);
});

const response = pm.response.json();

const availableBooks = response.filter(book => book.available === true);
const book = availableBooks[0] || null;

pm.test("Book Found", () => {
    pm.expect(book, "No available books found").to.not.be.null;
    pm.expect(book).to.be.an('object');
    pm.expect(book.available).to.be.true;
});

if (book) {
    pm.globals.set("bookId", book.id);
}

console.log(book);


// the rest can be found in the postman API Documentation. 
https://learning.postman.com/docs/tests-and-scripts/write-scripts/postman-sandbox-reference/overview
